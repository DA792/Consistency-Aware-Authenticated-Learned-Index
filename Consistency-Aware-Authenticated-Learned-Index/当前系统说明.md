# 当前系统说明

## ✅ 系统配置

**二维PVL树 + 并行查询**

---

## 🎯 核心特性

### 1. 查询模式

| 模式 | 状态 | 说明 |
|------|------|------|
| **并行查询** | ✅ 启用 | 利用多核CPU加速 |
| 串行查询 | 可选 | 单核执行 |
| ~~批量查询~~ | ❌ 已删除 | 不可行(VO结构限制) |

### 2. 数据集

- **文件**: `src/data/uniform_500k.csv`
- **数量**: 500,000 点
- **分布**: 均匀分布
- **范围**: [0, 499999] × [0, 499999]

### 3. 索引参数

- **类型**: PVL树 (学习索引)
- **误差界限**: 256
- **Z-order递归深度**: 4

---

## 🚀 并行查询工作原理

### 原理:

```
多个Z区间在不同CPU核心上同时执行:

CPU核心1: 区间1  → 区间5  → 区间9  → ...
CPU核心2: 区间2  → 区间6  → 区间10 → ...  (同时)
CPU核心3: 区间3  → 区间7  → 区间11 → ...  (同时)
CPU核心4: 区间4  → 区间8  → 区间12 → ...  (同时)

关键: 每个区间仍然独立生成完整VO!
```

### 代码:

```java
// Spatial2DPVLTree.java
private Spatial2DPVL_Res rectangleQueryParallel(...) {
    // 并行处理每个Z区间
    List<Result> results = intervals.parallelStream()
        .map(interval -> {
            // 每个区间独立查询,生成完整VO
            PVL_Res pvlResult = pvlTree.rangeQuery(interval.start, interval.end);
            // 处理结果...
            return result;
        })
        .collect(Collectors.toList());
}
```

---

## 📊 预期性能 (4核CPU)

### 选择性 0.01:

| 指标 | 串行 | 并行 | 提升 |
|------|-----|------|------|
| 查询时间 | 0.75 ms | ~0.25 ms | 3x |
| 验证时间 | 1.53 ms | ~0.45 ms | 3.4x |
| 总时间 | 2.28 ms | ~0.70 ms | 3.3x |

### 不同选择性:

| 选择性 | Z区间数 | 串行时间 | 并行时间 | 加速比 |
|--------|---------|---------|---------|--------|
| 0.0001 | ~5 | 0.19 ms | 0.08 ms | 2.4x |
| 0.001 | ~15 | 0.39 ms | 0.13 ms | 3.0x |
| 0.01 | ~49 | 2.28 ms | 0.70 ms | 3.3x |
| 0.1 | ~154 | 26.0 ms | 7.5 ms | 3.5x |

**结论**: Z区间越多,并行加速越明显!

---

## 🔧 使用方法

### 运行测试:

```batch
cd Consistency-Aware-Authenticated-Learned-Index
run_2d_pvl_test.bat
```

### 切换查询模式:

```java
// 启用并行查询 (默认)
tree.setUseParallelQuery(true);

// 切换回串行查询
tree.setUseParallelQuery(false);
```

---

## 📈 输出格式

```
===== 二维PVL树性能测试 =====

1. 加载数据集 (50万点)
数据统计: 500000 个点
X范围: [0, 499999]
Y范围: [0, 499999]

2. 构建二维PVL索引 (使用学习索引)
构建时间: 811.28 ms
误差界限(允许预测误差): ±256
说明: 已使用PLA(分段线性拟合)构建学习索引
Z-order映射表大小: 499998 个条目

3. 查询性能测试 (50万点数据集)
查询次数: 1000
查询选择性: [0.0001, 0.001, 0.01, 0.1]

===== 查询选择性: 0.01 =====
【查询性能】
  平均查询时间: ~0.25 ms  ← 并行加速
  平均验证时间: ~0.45 ms  ← 并行加速
  平均总时间: ~0.70 ms    ← 比串行快3.3倍
  验证开销: 64.3%
【统计信息】
  平均VO大小: 31.19 KB
  平均结果数: 4998
  平均Z区间数: 49
  平均候选数: 5535
  平均假阳性: 538
  假阳性率: 9.73%

===== 测试完成 =====
```

---

## 💡 关键理解

### 并行查询 ≠ 批量查询

| 特性 | 批量查询 | 并行查询 |
|------|---------|---------|
| **VO生成** | 多个区间共享1个VO | 每个区间独立生成VO |
| **可行性** | ❌ 不可行 | ✅ 可行 |
| **加速原理** | 减少树遍历 | 利用多核CPU |
| **验证** | 需要新逻辑 | 逻辑不变 |

### 为什么批量查询不可行?

```java
// VoInfo结构限制
public class VoInfo {
    public int startPos;  // ← 只能记录1个位置
    public int endPos;    // ← 只能记录1个位置
    // 无法同时记录多个查询路径!
}
```

### 为什么并行查询可行?

```java
// 每个区间独立生成完整VO
区间1 → VoInfo1 (完整)  ← CPU核心1
区间2 → VoInfo2 (完整)  ← CPU核心2 (同时)
区间3 → VoInfo3 (完整)  ← CPU核心3 (同时)
区间4 → VoInfo4 (完整)  ← CPU核心4 (同时)

每个VO都是完整的,互不干扰!
```

---

## 🎯 优化建议

### 当前配置 (err=256, level=4):

**特点:**
- ✅ 平衡性能和精度
- ✅ 适合50万数据规模
- ✅ 假阳性率可接受 (10-50%)
- ✅ 并行加速明显 (3-3.5倍)

### 如果需要更快:

1. **增大误差界限**
   ```java
   int err = 512;  // 从256改为512
   ```
   - 树更浅,查询更快
   - 假阳性会增加

2. **减少Z区间**
   ```java
   if (level >= 3 || ...) {  // 从4改为3
   ```
   - 查询次数减少
   - 单个区间更大

### 如果需要更精确:

1. **减小误差界限**
   ```java
   int err = 128;  // 从256改为128
   ```
   - 假阳性减少
   - 查询稍慢

2. **增加Z区间精度**
   ```java
   if (level >= 5 || ...) {  // 从4改为5
   ```
   - 更精确的区间划分
   - 查询次数增加

---

## 📚 相关文档

- `并行查询配置.md` - 并行查询详细说明
- `性能优化方案-不改验证.md` - 其他优化方案
- `当前配置说明.md` - 完整配置说明
- `50万数据集测试配置.md` - 数据集说明

---

## 🎓 总结

### 当前系统:

- ✅ **索引**: PVL树 (学习索引)
- ✅ **查询**: 并行查询 (利用多核)
- ✅ **验证**: 完整认证 (每个区间独立VO)
- ✅ **性能**: 比串行快3-3.5倍
- ✅ **安全**: 完整的认证保证

### 核心优势:

1. **查询快** - 学习索引优化
2. **验证快** - 并行执行
3. **可扩展** - 利用多核CPU
4. **安全** - 完整认证保证

---

**现在可以运行测试,体验并行查询的加速效果!** 🚀

```batch
run_2d_pvl_test.bat
```

